// eeprom_init.c
// Inicjalizacja EEPROM domy?ln? zawarto?ci? i magicznym bajtem
#include "eeprom_init.h"
#include <xc.h>
#include <stdint.h>

// Domy?lna zawarto?? EEPROM (256 bajtów)
const uint8_t eeprom_init_data[EEPROM_INIT_DATA_SIZE] = {
    // 0x00 - 0x0F
    0x00,0x00,0x53,0x74,0x61,0x72,0x74,0x75,0x70,0x20,0x00,0x00,0x20,0x20,0x20,0x20,
    // 0x10 - 0x1F
    0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
    // 0x20 - 0x2F
    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,
    // 0x30 - 0x3F
    0x20,0x20,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x20,
    // 0x40 - 0x4F
    0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
    // 0x50 - 0x5F
    0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x20,0x20,0x20,
    // 0x60 - 0x6F
    0x20,0x20,0x20,0x20,0x44,0x2A,0x81,0x00,0xBC,0x02,0x64,0x00,0x3C,0x00,0xB4,0x00,
    // 0x70 - 0x7F
    0x64,0x00,0x01,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0x80 - 0x8F
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0x90 - 0x9F
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0xA0 - 0xAF
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0xB0 - 0xBF
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0xC0 - 0xCF
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0xD0 - 0xDF
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0xE0 - 0xEF
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    // 0xF0 - 0xFF
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
    
};

void EEPROM_InitDefault(void)
{
    // Sprawd? magiczny bajt
    if (eeprom_read(MAGIC_BYTE1_ADDR) == MAGIC_BYTE1_VAL)
        return; // EEPROM ju? zainicjowany

    // Zapisz ca?? zawarto?? EEPROM (oprócz magic byte)
    for (uint16_t i = 0; i < 0xFF; i++) {
        eeprom_write(i, eeprom_init_data[i]);
    }
    // Ustaw magic byte
    eeprom_write(MAGIC_BYTE1_ADDR, MAGIC_BYTE1_VAL);
}

// Implementacja dla XC8 (PIC16F1938 i podobne)
void eeprom_write(uint8_t addr, uint8_t value)
{
    EEADRL = addr;      // Adres EEPROM
    EEDATL = value;     // Warto?? do zapisania
    EECON1bits.EEPGD = 0;   // Wybierz pami?? danych EEPROM
    EECON1bits.CFGS = 0;    // Wybierz pami?? EEPROM, nie konfiguracji
    EECON1bits.WREN = 1;    // W??cz zapis

    // Sekwencja odblokowania (zgodnie z datasheet)
    uint8_t gie_state = INTCONbits.GIE; // Zapami?taj stan przerwa?
    INTCONbits.GIE = 0;     // Wy??cz przerwania
    EECON2 = 0x55;
    EECON2 = 0xAA;
    EECON1bits.WR = 1;      // Rozpocznij zapis
    while (EECON1bits.WR);  // Czekaj na zako?czenie zapisu
    EECON1bits.WREN = 0;    // Wy??cz zapis
    INTCONbits.GIE = gie_state; // Przywró? stan przerwa?
}

uint8_t eeprom_read(uint8_t addr)
{
    EEADRL = addr;          // Adres EEPROM
    EECON1bits.EEPGD = 0;   // Wybierz pami?? danych EEPROM
    EECON1bits.CFGS = 0;    // Wybierz pami?? EEPROM, nie konfiguracji
    EECON1bits.RD = 1;      // Rozpocznij odczyt
    NOP();                  // Zalecane przez Microchip
    return EEDATL;          // Zwró? odczytan? warto??
}